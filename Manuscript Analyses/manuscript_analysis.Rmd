---
title: Cognitive and Auditory Predictors of Dysarthric Speech Understanding in Older
  Adult Listeners
author: "Lansford, Hirsch, Barrett, & Borrie"
date: "`r Sys.Date()`"
output: 
  github_document:
    code_folding: hide
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Purpose

This document contains the analysis code and output for the manuscript entitled "Cognitive and Auditory Predictors of Dysarthric Speech Understanding in Older Adult Listeners". These results will also be presented at the Biannual Motor Speech Conference held in San Diego, CA from February 21-24, 2024.

The data preprocessing script can be found in the Manuscript Analyses subdirectory in this repo.

All data processing and analyses was conducted using R Version 4.3.2.


```{r, echo = F, warning = F, message = F}

# Loading in needed packages
library(tidyverse) #install.packages("tidyverse")
library(rio) #install.packages("rio")
library(gt) #install.packages("gt")
library(gtsummary) #install.packages("gtsummary")
library(reshape2) #install.packages("reshape2")
library(ggcorrplot) #install.packages("ggcorrplot")
library(patchwork) #install.packages("patchwork")
library(janitor) #install.packages("janitor")
library(fs) #install.packages("fs")
library(furniture) #install.packages("furniture")
library(caret) #install.packages("caret")
library(effectsize) #install.packages("effectsize")
library(parameters) #install.packages("parameters")
library(performance) #install.packages("performance")
library(bayestestR) #install.packages("bayestestR)
library(rstanarm) #install.packages("rstanarm")
library(afex) #install.packages("afex")
library(glmnet) #install.packages("glmnet")

# Load in datasets

## Listener Demographic Information
demo <- rio::import("participant_demo.csv")

## Listener Intelligibility and Cognition Scores
data <- rio::import("cleaned_data.csv")

```



```{r, warning = F, message = F}

# Calculating pretest and posttest intelligibility for the listeners
pl_int <- data %>%
  dplyr::group_by(id, speaker, type) %>%
  dplyr::mutate(pwc = (sum(correct_words)/sum(target_number))*100,
                best_win = ifelse(win_r < win_l, win_r, win_l)) %>%
  dplyr::summarize(pwc = mean(pwc, na.rm = T),
                   across(c(contains("_c"), contains("_u"), contains("win")),
                          ~first(.x)
                          )) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(type = as.factor(type),
                type = fct_relevel(type, "pretest", "posttest"))

# Subsetting age from demo df

age <- demo %>%
  select(id, age)

# Merging listener age into pl_int

pl_int <- dplyr::left_join(age, pl_int, by = "id") 


cor_df <- pl_int %>%
  tidyr::pivot_wider(names_from = type,
                     values_from = pwc) %>%
  dplyr::mutate(improvement = posttest - pretest) %>%
  dplyr::select(id, speaker, ends_with("_c"), best_win, pretest, posttest, improvement)

```


```{r, echo = F, message = F, warning = F}

# removing unneeded objects from the environment
rm(age, data)

```


# Descriptives

## Participant Demographics

TBD

```{r}



```

## Cognition

In this study, listeners were assigned to one of two speakers for perceptual training: a speaker with Ataxic dysarthria (AM1) or a speaker with Parkinson's disease (PDM10). Means and standard deviation for listener age, cognition, and word in noise hearing threshold for each condition are presented below. Wilcoxon rank sum tests were performed for each of the measures. None of the cognition or hearing measures were significantly different between the two groups. 

```{r, warning = F, message = F}

cog_table <- pl_int %>%
  dplyr::filter(type == "pretest") %>%
  dplyr::select(id, speaker, age, ends_with("_c"), best_win) %>%
  dplyr::select(-fluid_cog_c) %>%
  dplyr::rename(
    `Working Memory` = list_sort_c,
    `Inhibitory Control` = flanker_c,
    `Cognitive Flexibility` = card_sort_c,
    `Receptive Vocabulary` = vocab_c,
    `Processing Speed` = pattern_c,
    `Picture Sequence Memory` = pic_seq_c,
    `Words in Noise Threshold` = best_win
  ) %>%
  group_by(id, speaker) %>% 
  summarize(across(everything(), first)) %>% 
  ungroup() %>% 
  select(-id) %>% 
  tbl_summary(
    by = "speaker",
    statistic = list(all_continuous() ~ "{mean} ({sd})"),
    missing = "no",
    digits = list(everything() ~ c(2))
  ) %>% 
  add_p() %>%
  as_gt() 

cog_table

cog_table %>%
  gt::gtsave("Tables/means_tabel.html")

```

## Intelligibility

Pretest and posttest intelligibility, as measured by percent words correct, for each of the two speaker conditions are presented below. On average, pretest intelligibility for AM1 was lower than PDM10. However, the listener's who were trained with AM1, on average, had greater intelligibility gains at posttest compared to the listener's trained with PDM10. A repeated measures ANOVA was conducted on the pretest-posttest change for the AM1 was significant (F(1,32) = 103.69, p < .001, d = 1.01).

```{r, warning = F, message = F}

# Intelligibility Descriptives Table

speaker_intel <- pl_int %>%
  dplyr::mutate(type = as.factor(type),
                type = fct_relevel(type, "pretest", "posttest")) %>%
  dplyr::group_by(speaker, type) %>%
  dplyr::summarize(m_pwc = mean(pwc),
                   sd_pwc = sd(pwc)) %>%
  dplyr::ungroup() %>%
  tidyr::pivot_wider(names_from = speaker,
                     values_from = c(m_pwc:sd_pwc)) %>%
  dplyr::relocate(sd_pwc_AM1, .after = m_pwc_AM1) %>%
  gt::gt() %>%
    fmt_number(columns = "m_pwc_AM1":"sd_pwc_PDM10", decimals = 2) %>%
    tab_spanner(label = "AM1",
                columns = c(m_pwc_AM1, sd_pwc_AM1)) %>%
    tab_spanner(label = "PDM10",
                columns = c(m_pwc_PDM10, sd_pwc_PDM10)) %>%
    cols_label(type = " ",
               m_pwc_AM1 = "Mean",
               sd_pwc_AM1 = "SD",
               m_pwc_PDM10 = "Mean",
               sd_pwc_PDM10 = "SD")

speaker_intel

speaker_intel %>%
  gt::gtsave("Tables/intel_des.html")

```

### Pretest - Posttest Plot

```{r, warning = F, message = F}

pl_int %>%
  ggplot() +
  aes(x = type,
      y = pwc,
      group = id) +
  geom_line(alpha = 0.3) +
  stat_summary(aes(group = speaker),
               fun.y = mean, geom = "line", linewidth = 2) +
  facet_wrap("speaker") +
  labs(x = "Phase", y = "Intelligibility") +
  theme_bw() +
  theme(legend.position = "none", aspect.ratio = 1)

ggsave("Plots/Pre_post.png", plot = last_plot())

```

```{r}

cor_df %>% 
  dplyr::select(id, speaker, pretest, posttest) %>% 
  tidyr::pivot_longer(pretest:posttest) %>% 
  dplyr::group_by(speaker) %>% 
  dplyr::group_nest() %>% 
  dplyr::mutate(
    mod = map(data, ~afex::aov_4(value ~ 1 + (name|id), data = .x))
  ) %>% 
  pull(mod)

cor_df %>% 
  dplyr::select(id, speaker, pretest, posttest) %>% 
  tidyr::pivot_longer(pretest:posttest) %>% 
  dplyr::group_by(speaker) %>% 
  dplyr::group_nest() %>% 
  dplyr::mutate(
    mod = map(data, ~effectsize::cohens_d(value ~ name, data = .x))
  ) %>% 
  pull(mod)

```


# Results

## Correlations

The correlation matricies between all the cognitive measures, hearing threshold, initial intelligibility, and intelligibility improvement were conducted for each speaker condition.

### AM1

```{r, warning = F, message = F}

AM1_cor <- cor_df %>%
  dplyr::filter(speaker == "AM1") %>%
  dplyr::select(!c(id, speaker, fluid_cog_c, posttest)) %>%
  dplyr::rename(
    `Working Memory` = list_sort_c,
    `Inhibitory Control` = flanker_c,
    `Cognitive Flexibility` = card_sort_c,
    `Receptive Vocabulary` = vocab_c,
    `Processing Speed` = pattern_c,
    `Picture Sequence Memory` = pic_seq_c,
    `Words in Noise Threshold` = best_win
  ) %>%
  dplyr::rename_all(snakecase::to_title_case) %>%
  cor(use = "pairwise.complete.obs") %>%
  ggcorrplot(
    type = "lower",
    outline.col = "white",
    colors = c("#6D9EC1", "white", "#E46726"),
    lab = TRUE,
    insig = "blank",
    title = "Ataxic", 
    legend.title = "Correlation"
  )
  
AM1_cor

```

### PDM10

```{r, warning = F, message = F}

PDM10_cor <- cor_df %>%
  dplyr::filter(speaker == "PDM10") %>%
  dplyr::select(!c(id, speaker, fluid_cog_c, posttest)) %>%
  dplyr::rename(
    `Working Memory` = list_sort_c,
    `Inhibitory Control` = flanker_c,
    `Cognitive Flexibility` = card_sort_c,
    `Receptive Vocabulary` = vocab_c,
    `Processing Speed` = pattern_c,
    `Picture Sequence Memory` = pic_seq_c,
    `Words in Noise Threshold` = best_win
  ) %>%
  dplyr::rename_all(snakecase::to_title_case) %>%
  cor(use = "pairwise.complete.obs") %>%
  ggcorrplot(
    type = "lower",
    outline.col = "white",
    colors = c("#6D9EC1", "white", "#E46726"),
    lab = TRUE,
    insig = "blank",
    title = "Parkinson's Disease", 
    legend.title = "Correlation"
  )

PDM10_cor

```

```{r, echo = F, warning = F, message = F}

library(patchwork)
AM1_cor + PDM10_cor + plot_layout(guides = "collect") & theme(legend.position = "bottom")
ggsave("Plots/cor_fig.png", width = 20, height = 6, dpi = 300, units = "in")

rm(AM1_cor, PDM10_cor, cog_table, speaker_intel)

```

## Models of Initial Intelligibility

TBD

```{r, warning = F, message = F}

# Functions used in this code

## Plot importance function
plot_importance = function(mods, labels){
  map2(mods, labels, ~var_imp(.x, .y)) %>% 
    reduce(full_join, by = "var") %>% 
    ungroup() %>% 
    pivot_longer(-var) %>% 
    group_by(var) %>% 
    mutate(avg_imp = mean(value, na.rm=TRUE)) %>% 
    ungroup() %>% 
    arrange(avg_imp) %>% 
    mutate(var = fct_inorder(var))
}

## Function for determining variable importance
var_imp <- function(mod, label) {
  varImp(mod)$importance %>%
    rownames_to_column(var = "Variable") %>%
    mutate(Overall = Overall/max(Overall)) %>%
    rename(!!label := Overall, 
          var = Variable)
}

## Function for model training
training <- function(data, method, int) {
  form = if (isTRUE(int)) {
    d2 = model.matrix(mean_pwc ~ . * ., data = data)[, -1] %>%
      as_tibble() %>%
      janitor::clean_names()
    d2$mean_pwc = data$mean_pwc
  } else {
    d2 = data
    train(
      mean_pwc ~ ., 
      data = d2, 
      preProcess = c("center", "scale"),
      method = method, 
      trControl = caret::trainControl(
        method = "repeatedcv",
        number = 5,
        repeats = 10
    ))
  }
}

```


```{r}

set.seed(7036)

mod_fun = function(speaker, type){
  subsetted = pl_int %>% 
    filter(type == {{type}}) %>% 
    filter(speaker == {{speaker}}) %>% 
    select(mean_pwc, ends_with("_c"), best_win) %>% 
    drop_na(mean_pwc, ends_with("_c"), best_win) %>% 
    select(-contains("fluid"))
  
  mod.1 = training(subsetted, "glmnet", int = FALSE)
  mod.2 = training(subsetted, "glmnet", int = TRUE)
  
  return(list(mod.1, mod.2))
}

plot_fun = function(mods, title){
  plot_importance(
    mods = mods,
    labels = c("main", "int")
  ) %>% 
    drop_na(value) %>% 
    mutate(name = factor(
      name, 
      levels = c("main", "int"),
      labels = c(
        paste0("Main Effects"),
        paste0("Interactions")
    ))) %>% 
    filter(name == "Interactions") %>% 
    mutate(var = str_replace(var, "flanker_c", "Inhibitory Control of Attention"),
           var = str_replace(var, "card_sort_c", "Cognitive Flexibility"),
           var = str_replace(var, "vocab_c", "Vocabulary Knowledge"),
           var = str_replace(var, "pattern_c", "Processing Speed"),
           var = str_replace(var, "list_sort_c", "Working Memory"),
           var = str_replace(var, "pic_seq_c", "Picture Sequence Memory"),
           var = str_replace(var, "best_win", "Words in Noise Threshold"),
           var = str_replace(var, "_", " x ")) %>% 
    arrange(value) %>% 
    mutate(var = fct_inorder(var)) %>% 
    ggplot(aes(x = value, y = var, color = value)) +
    geom_segment(aes(xend = 0, yend = var)) +
    geom_point(size = 2) +
    facet_wrap(~name, scales = "free") +
    labs(x = "Relative Importance",
         y = "",
         title = {{title}}) +
    scale_color_viridis_c(option = "magma", end = .8) +
    theme(plot.title.position = "plot")
}

mods1 = mod_fun("AM1", "pretest")
mods2 = mod_fun("PDM10", "pretest")

p1 = plot_fun(mods1, "a) Ataxic")
p2 = plot_fun(mods2, "b) PD")

```

